<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Day 7</title>
    <meta charset="utf-8" />
    <meta name="author" content="Andrew Murray" />
    <meta name="date" content="2020-06-30" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="my_styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




&lt;br&gt;&lt;br&gt;
.center[
## Introduction to Geographic Information
### Lecture 6
.mb[
Data Models for GIS&lt;br&gt;


&lt;br&gt;

Andrew Murray | University of North Carolina - Chapel Hill

June 30, 2020
]]

---

.center[
## Rasters
]

.pull-left[
&lt;img src="raster.jpg" width="450" height="350" /&gt;
]

.pull-right[
.med[
- Rasters are made up of pixels
- Each square in the image to the left represents a single pixel
- All pixels within a raster are always the same size
- We refer to the the length of one side of a pixel as the resolution. So when we say a raster has a resolution of 30 meters, we mean that each pixel is 30m x 30m
- Satellite imagery is the most common form of raster data
]
]

???

Before a raster is projected, it is composed of squares of equal size. You will often hear people talk about rasters in terms of their resolution. the resolution of the raster refers to the length of one side of a pixel square. Rasters are considered simple because of the way they are stored. As I have already mentioned, points, lines and polygons are composed of coordinate pairs that tell us how to draw them. Rasters are similar. Rasters have a y-min, a y-max an x-min and an x-max. These represent the bottom, top, left and right borders respectively. That is the only imformation you need to draw a raster. Beyond that, a raster is just a matrix that stores values. You can think of this as a spreadsheet where each cell has a specific value. There are many types of rasters which determine the types of values that can be stored.

---

## Example: Watershed Delineation

.pull-left[
&lt;img src="dem17n.jpg" width="450" height="350" /&gt;

This Raster shows elevation and is referred to as a Digital Elevation Model (DEM)

]

.pull-right[
&lt;img src="flowdirection.png" width="450" height="250" /&gt;

Each Pixel reflects the elevation of a pixel, and using GIS we can figure out the flow direction of water over the surface

]

???

One of my personal focus areas of research is on water resources. One of the foundational things that hydrologists or people who study water need to do is understand how water travels accross the earths surface. The way we figure this out is by using a digital elevation model (DEM). A DEM is a raster file where each pixel represents the elevation of the earths surface. We can take this and use GIS to figure out the steepest slope from every single pixel to every other pixel immediately next to it. This then tells us the flow direction of water. From this, we can figure out where water flows over the entire surface of the earth as long as we have elevation data. Without this, things like flood planning would be impossible.

---

## Pros and Cons of Raster Data

.med[
.pull-left[

**Pros**
- Rasters are efficient for visualizing data over large geographic regions
  - Like data for the tnire U.S.
- Continued advances in technology have made advanced operations on Rasters more accessible
- Remote sensing data is delivered using rasters because that is how it is aquired (The same way a camera creates a raster by taking a picture)
]

.pull-right[
**Cons**
- Cannot have various spatial scales within a single file
- limited to a single attribute per raster
- Very large
- Creating a Raster, by definition, means a loss of data by averaging or some other mathematical operation.
]
]

???

There are many pros and cons to the use of raster data. A lot of the historical 

---

## Popular Raster Data

.pull-left[
&lt;img src="examples.png" width="500" height="450" /&gt;
]

.pull-right[

## Demo.med[
Now I want to take you through some actual examples of using raster data and how to view some basic pixel operations.

Please follow the link here to watch the tutorial:

[LINK]()
]



]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightLines": true,
"highlightStyle": "github",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<script type='text/javascript'>

var slideElements

  function getElementForSlide(slide) {
    slideElements = slideElements || document.querySelectorAll('.remark-slide')
    return slideElements[slide.getSlideIndex()]
  }

  slideshow.on('showSlide', function (slide) {
    Array.from(getElementForSlide(slide).querySelectorAll('video, audio')).forEach(function (vid) {
      vid.loop = false
      vid.currentTime = 0
      vid.play()
    })
  })

  slideshow.on('hideSlide', function (slide) {
    Array.from(getElementForSlide(slide).querySelectorAll('video, audio')).forEach(function (vid) {
      vid.pause()
    })
  })

</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
